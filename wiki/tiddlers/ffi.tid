created: 20180717110417939
modified: 20180720105516583
title: ffi
type: text/vnd.tiddlywiki

!! Context

After compiled, C source code gets transformed to binary instructions. During this process, we drop all calling context. Some other programs may not know what arguments are to be passed to a function in this program.

Here is an example. First we save our source code in `mymodule.h` and `mymodule.c`. Header file `mymodule.h` has all function signatures like below:

```
#ifndef MYMODULE_H
#define MYMODULE_H

typedef struct point point_t;

struct point {
  double x;
  double y;
};

double get_point_distance(const point_t* p1, const point_t* p2);

#endif
```

The implementation of `mymodule.c` gets compiled into `libmymodule.so`. (`gcc -shared -o libmymodule.so mymodule.c`)

In Python or Lua or Ruby, we can dynamically load `libmymodule.so` via `dlopen` in Unix and `LoadLibrary` in Windows. 

```
void (*f)(void);

void* lib = dlopen("libmymodule.so", RTLD_LAZY);
if (lib == NULL)
    fatal("dlopen failed: %s", dlerror());

f = (void (*)(void)) dlsym(lib, "point_distance");
```

We now have the address of function in dynamic library. However, we actually don't know what parameters to send and what is return type, because all things in `libmodule.so` are machine instructions on top of registers like `%esi`, `%xmm0`, not `const point_t* p1, const point_t* p2` any more.

[img[ffi-after-dlopen.jpg]]

It's easy to know such information in C by sharing header file definition, but calling it in another language might seems a big challenge.

FFI is a technology that solved this problem.

!! Overview

FFI, or Foreign Function Interface, allows code written in one language to call code written in another language. The major use case is for dynamic VM languages. For example, Python has CFFI, same as Ruby, Java, Lua using it in similar C FFI libraries.

Basically after dynamically loaded and resolved symbols in `.so` or `.ddl` file, we use FFI constructing foreign function call.

FFI code can be described in below steps:

* Define C struct fields, C function parameters and return types, etc.
* Construct an ffi call struct, and run things like `ffi_call`.

!! Solutions

!!! LuaJit - FFI

The LuaJit FFI library allows calling external C functions and using C data structures from pure Lua code. It parses plain C declarations first. The arguments passed to this function are automatically converted from Lua objects to the corresponding C types. After `printf` call, LuaJit automatically converts C return types back to Lua objects.

Below is the `hello world` example.

```
local ffi = require("ffi")
ffi.cdef[[
int printf(const char *fmt, ...);
]]
ffi.C.printf("Hello %s!", "world")
```

Non-trivial C Struct is also supported. `ffi.cdef` below let LuaJit remember the essential field names and field bytesize. `ffi.new` below creates a non-fixed-sized array of a C struct.

```
ffi.cdef[[
typedef struct point point_t;
struct point {
  double x;
  double y;
};
]]
local points = ffi.new("point_t[?]", n)
points[1].x = 1.0
points[2].y = 3.0
```

!!! Python - CFFI

Python CFFI provides similar interfaces to LuaJit except that it support more calling conventions including ABI & in-line, ABI & out-of-line, API & in-line, ABI & out-of-line.

Below is its hello-world example:

```
from cffi import FFI
ffi = FFI()
ffi.cdef("""
    int printf(const char *format, ...);   // copy-pasted from the man page
""")
C = ffi.dlopen(None)                     # loads the entire C namespace
arg = ffi.new("char[]", "world")         # equivalent to C code: char arg[] = "world";
C.printf("hi there, %s.\n", arg)         # call printf
```

Below is an equivalent example of C Struct usage.

```
ffi = FFI()
ffi.cdef("""
typedef struct point point_t;
struct point {
  double x;
  double y;
};
""")
points = ffi.new("point_t[]", 2)
points[0].x = 1.0
points[1].y = 3.0
```

!!! Ruby - FFI

Ruby code integrating FFI looks very traditional `Ruby` stylish.

```
require 'ffi'

module Hello
  extend FFI::Library
  ffi_lib FFI::Library::LIBC
  attach_function :puts, [ :string ], :int
end

Hello.puts("Hello, World")
```

`require 'ffi'` loads and initializes FFI library. `extend FFI::Library` attach FFI functionalities to module Hello. Below two lines we declare loading libc and loading `puts` function, which receives string as parameter and return int value.

Defining struct also looks in OO style.

```
class Point < FFI::Struct
  layout :x, :int
  layout :y, :int
end

attach_function 'get_point_distance', [ :pointer ], :int
```

!!! Common Lisp - FFI

ANSI Common Lisp has FFI as well. It's CFFI, or Common Foreign Function Interface.  In Common Lisp, we also split the calls into three steps: 1) load c lib, 2) define types, 3) call.

```
;;; load library
(asdf:load-system :cffi)
(defpackage :cffi-user
    (:use :common-lisp :cffi))

(define-foreign-library libc
  (t (:default "libc")))

(use-foreign-library libc)

(defcfun "printf" :int (str :pointer) &rest))

(printf "hello world")
```

Everything expressed in Common Lisp is just in S-expression, even when you're writing CFFI bindings. This make coding a lot easier.

!!! Rust - FFI

Ruby has smart compiler so it doesn't need you to vendor c source code or provide type symbols, instead, you write plain Rust code to `extern` c code. Below is a minimal example of calling a library `snappy`.

```
extern crate libc;
use libc::size_t;

#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -> size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
```

`extern { ... }` let you wrap function definition together. `[#link(name="snappy")]` is a hint to Rust compiler to instruct the linker to link against the snappy library.

Note that when we call defined function, the call is actually wrapped by `unsafe` keyword. In Rust, we tend to believe it's unsafe when we write C code since we lost the power of Rust compiler checking type or referencing security.

!!! Pony - FFI

In Pony, you can use FFI directly. The FFI call syntax is very much like normal function call with little difference. Below example shows how to call `fwrite`.

```
@fwrite[U64](data.cstring(), U64(1), data.size(), _handle)
```

The benefit of calling without definition looks convenient. Nonetheless, it's very dangerous. Being able to do this doesn't mean that you should do it in this way. Without signature, it might cause potential bug. And hence, it's still recommended to define signature first. Pony declare function signature via `use` keyword.

```
use @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32,
  parg: Pointer[U8] tag) if windows

use @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64,
  parg: Pointer[U8] tag) if not windows

class SSLContext val
  new create() =>
    // set SSL_OP_NO_SSLv2
    @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8])
```

`use @` here tells Pony compiler it's a FFI definition.

!!! C - libffi

libffi is very likely fundamental library that built into majority of VM languages written in C language. It has very basic form. Below code comes from [[libffi simple example|http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Simple-Example.html#Simple-Example]]:

```
#include <stdio.h>
#include <ffi.h>

int main()
{
  ffi_cif cif;
  ffi_type *args[1];
  void *values[1];
  char *s;
  ffi_arg rc;
  
  /* Initialize the argument info vectors */    
  args[0] = &ffi_type_pointer;
  values[0] = &s;
  
  /* Initialize the cif */
  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_sint, args) == FFI_OK)
    {
      s = "Hello World!";
      ffi_call(&cif, puts, &rc, values);
      /* rc now holds the result of the call to puts */
      
      /* values holds a pointer to the function's arg, so to 
         call puts() again all we need to do is change the 
         value of s */
      s = "This is cool!";
      ffi_call(&cif, puts, &rc, values);
    }
  
  return 0;
}
```

It has a set of `ffi_` prefixed functions. Especially, `ffi_prep_cif` is used to define signature, `ffi_prep_cif_var` is used to define signature for those varargs needed, `ffi_call` is for making calls.

!! Patterns

!!! How it works
!!! ABI v/s API
!!! CIF Description
!!! Long Long
!!! Alignment
!!! 32 v/s 64
!!! Exchange
!!! Type Conversion
!!! Callback
!!! Garbage Collect
!!! Thread-safe v/s Thread-unsafe
!!! Interfaces Comparison

!! Conclusions

!! References

* [[Flexible runtime interface to shared libraries with libffi|https://eli.thegreenplace.net/2013/03/04/flexible-runtime-interface-to-shared-libraries-with-libffi]]
* [[Why use FFI|https://github.com/ffi/ffi/wiki/Why-use-FFI]]
* [[LuaJit - FFI|http://luajit.org/ext_ffi.html]]
* [[Python - CFFI|https://cffi.readthedocs.io/en/latest/overview.html]]
* [[Using LibFFI|http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Using-libffi.html#Using-libffi]]
* [[Java JNI example|https://stackoverflow.com/questions/5963266/call-c-function-from-java]]
* [[Pony - FFI|https://tutorial.ponylang.org/c-ffi/]]
* [[Rust - FFI|https://doc.rust-lang.org/book/first-edition/ffi.html]]
* [[CommonLisp - FFI|https://common-lisp.net/project/cffi/manual/cffi-manual.html]]
* [[Example of source code in this post|https://gist.github.com/soasme/1ddbf4de79e341cbf2e0cf7357a166f7]]
* [[How libffi actually works?|http://techbrahmana.blogspot.com/2008/08/how-libffi-actually-works.html]]