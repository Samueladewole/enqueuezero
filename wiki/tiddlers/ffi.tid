created: 20180717110417939
modified: 20180720121826779
title: ffi
type: text/vnd.tiddlywiki

!! Context

After compiled, C source code gets transformed to binary instructions. During this process, we drop all calling context. Some other programs may not know what arguments are to be passed to a function in this program.

Here is an example. First we save our source code in `mymodule.h` and `mymodule.c`. Header file `mymodule.h` has all function signatures like below:

```
#ifndef MYMODULE_H
#define MYMODULE_H

typedef struct point point_t;

struct point {
  double x;
  double y;
};

double get_point_distance(const point_t* p1, const point_t* p2);

#endif
```

The implementation of `mymodule.c` gets compiled into `libmymodule.so`. (`gcc -shared -o libmymodule.so mymodule.c`)

In Python or Lua or Ruby, we can dynamically load `libmymodule.so` via `dlopen` in Unix and `LoadLibrary` in Windows. 

```
void (*f)(void);

void* lib = dlopen("libmymodule.so", RTLD_LAZY);
if (lib == NULL)
    fatal("dlopen failed: %s", dlerror());

f = (void (*)(void)) dlsym(lib, "point_distance");
```

We now have the address of function in dynamic library. However, we actually don't know what parameters to send and what is return type, because all things in `libmodule.so` are machine instructions on top of registers like `%esi`, `%xmm0`, not `const point_t* p1, const point_t* p2` any more.

[img[ffi-after-dlopen.jpg]]

It's easy to know such information in C by sharing header file definition, but calling it in another language might seems a big challenge.

FFI is a technology that solved this problem.

!! Overview

FFI, or Foreign Function Interface, allows code written in one language to call code written in another language. The major use case is for dynamic VM languages. For example, Python has CFFI, same as Ruby, Java, Lua using it in similar C FFI libraries.

Basically after dynamically loaded and resolved symbols in `.so` or `.ddl` file, we use FFI constructing foreign function call.

FFI code can be described in below steps:

* Define C struct fields, C function parameters and return types, etc.
* Construct an ffi call struct, and run things like `ffi_call`.

!! Solutions

!!! LuaJit - FFI

The LuaJit FFI library allows calling external C functions and using C data structures from pure Lua code. It parses plain C declarations first. The arguments passed to this function are automatically converted from Lua objects to the corresponding C types. After `printf` call, LuaJit automatically converts C return types back to Lua objects.

Below is the `hello world` example.

```
local ffi = require("ffi")
ffi.cdef[[
int printf(const char *fmt, ...);
]]
ffi.C.printf("Hello %s!", "world")
```

Non-trivial C Struct is also supported. `ffi.cdef` below let LuaJit remember the essential field names and field bytesize. `ffi.new` below creates a non-fixed-sized array of a C struct.

```
ffi.cdef[[
typedef struct point point_t;
struct point {
  double x;
  double y;
};
]]
local points = ffi.new("point_t[?]", n)
points[1].x = 1.0
points[2].y = 3.0
```

!!! Python - CFFI

Python CFFI provides similar interfaces to LuaJit except that it support more calling conventions including ABI & in-line, ABI & out-of-line, API & in-line, ABI & out-of-line.

Below is its hello-world example:

```
from cffi import FFI
ffi = FFI()
ffi.cdef("""
    int printf(const char *format, ...);   // copy-pasted from the man page
""")
C = ffi.dlopen(None)                     # loads the entire C namespace
arg = ffi.new("char[]", "world")         # equivalent to C code: char arg[] = "world";
C.printf("hi there, %s.\n", arg)         # call printf
```

Below is an equivalent example of C Struct usage.

```
ffi = FFI()
ffi.cdef("""
typedef struct point point_t;
struct point {
  double x;
  double y;
};
""")
points = ffi.new("point_t[]", 2)
points[0].x = 1.0
points[1].y = 3.0
```

!!! Ruby - FFI

Ruby code integrating FFI looks very traditional `Ruby` stylish.

```
require 'ffi'

module Hello
  extend FFI::Library
  ffi_lib FFI::Library::LIBC
  attach_function :puts, [ :string ], :int
end

Hello.puts("Hello, World")
```

`require 'ffi'` loads and initializes FFI library. `extend FFI::Library` attach FFI functionalities to module Hello. Below two lines we declare loading libc and loading `puts` function, which receives string as parameter and return int value.

Defining struct also looks in OO style.

```
class Point < FFI::Struct
  layout :x, :int
  layout :y, :int
end

attach_function 'get_point_distance', [ :pointer ], :int
```

!!! Common Lisp - FFI

ANSI Common Lisp has FFI as well. It's CFFI, or Common Foreign Function Interface.  In Common Lisp, we also split the calls into three steps: 1) load c lib, 2) define types, 3) call.

```
;;; load library
(asdf:load-system :cffi)
(defpackage :cffi-user
    (:use :common-lisp :cffi))

(define-foreign-library libc
  (t (:default "libc")))

(use-foreign-library libc)

(defcfun "printf" :int (str :pointer) &rest))

(printf "hello world")
```

Everything expressed in Common Lisp is just in S-expression, even when you're writing CFFI bindings. This make coding a lot easier.

!!! Rust - FFI

Ruby has smart compiler so it doesn't need you to vendor c source code or provide type symbols, instead, you write plain Rust code to `extern` c code. Below is a minimal example of calling a library `snappy`.

```
extern crate libc;
use libc::size_t;

#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -> size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
```

`extern { ... }` let you wrap function definition together. `[#link(name="snappy")]` is a hint to Rust compiler to instruct the linker to link against the snappy library.

Note that when we call defined function, the call is actually wrapped by `unsafe` keyword. In Rust, we tend to believe it's unsafe when we write C code since we lost the power of Rust compiler checking type or referencing security.

!!! Pony - FFI

In Pony, you can use FFI directly. The FFI call syntax is very much like normal function call with little difference. Below example shows how to call `fwrite`.

```
@fwrite[U64](data.cstring(), U64(1), data.size(), _handle)
```

The benefit of calling without definition looks convenient. Nonetheless, it's very dangerous. Being able to do this doesn't mean that you should do it in this way. Without signature, it might cause potential bug. And hence, it's still recommended to define signature first. Pony declare function signature via `use` keyword.

```
use @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32,
  parg: Pointer[U8] tag) if windows

use @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64,
  parg: Pointer[U8] tag) if not windows

class SSLContext val
  new create() =>
    // set SSL_OP_NO_SSLv2
    @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8])
```

`use @` here tells Pony compiler it's a FFI definition.

!!! C - libffi

libffi is very likely fundamental library that built into majority of VM languages written in C language. It has very basic form. Below code comes from [[libffi simple example|http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Simple-Example.html#Simple-Example]]:

```
#include <stdio.h>
#include <ffi.h>

int main()
{
  ffi_cif cif;
  ffi_type *args[1];
  void *values[1];
  char *s;
  ffi_arg rc;
  
  /* Initialize the argument info vectors */    
  args[0] = &ffi_type_pointer;
  values[0] = &s;
  
  /* Initialize the cif */
  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_sint, args) == FFI_OK)
    {
      s = "Hello World!";
      ffi_call(&cif, puts, &rc, values);
      /* rc now holds the result of the call to puts */
      
      /* values holds a pointer to the function's arg, so to 
         call puts() again all we need to do is change the 
         value of s */
      s = "This is cool!";
      ffi_call(&cif, puts, &rc, values);
    }
  
  return 0;
}
```

It has a set of `ffi_` prefixed functions. Especially, `ffi_prep_cif` is used to define signature, `ffi_prep_cif_var` is used to define signature for those varargs needed, `ffi_call` is for making calls.

!! Patterns

!!! How it works

FFI library call a function in dynamic library.

As you might know, everything in dynamic library are all machine instructions. FFI works by defining, constructing and sending exchange information. Calling function has nothing special but does some simple but non-trivial register value moving. Once done, we extract return value from exchange information.

!!! ABI v/s API

ABI, or application binary interface, is on the contrary of API. It's a term describing communications between programs in machine level.

Since FFI is constructing data structure into machine-level binary sequence, we can say that FFI use ABI to perform calls.

!!! Type Conversion

VM languages usually have two extra actions to take:

* Before calling `ffi_call`, convert language types into FFI types.
* After calling `ffi_call`, convert FFI types back to language types.

We can easily find such tables in every language FFI implementation:

|ffi types|language types|
|double,float|number|
|char *|string|
|book|boolean|
|struct|class|
|...|...|

Type conversion impacts performance but the impact is small considering below cases:

* Very slow: implement everything in VM languages.
* Very fast: implement code causing bottleneck in C, and call those not performance impacted in VM languages.
* Fastest: implement everything in C, or in assembly if you like. :)

The example in [[LuaJit FFI|http://luajit.org/ext_ffi.html]] shows LuaJit FFI call is 110x faster than in pure Lua interpreter.

!!! C Headers Copy-n-Paste v/s Semantic Signature

LuaJit ffi, and Python cffi supports copy-n-pasting C header file when defining function signatures. It's easy to use for users, cause the header file is very easy to find from library source code. The downside is that it needs to parse C code in runtime.

Ruby, and Common Lisp use semantic signatures, that is to explicitly define function name, argument types, and return type. Basically copy-n-pasting plus parsing builds on top of semantic signature.

Pony, and Rust are compiler languages, so they allow define signatures in their language code. It makes code styling more unified.

!!! !!! Alignment 32 bit v/s 64 bit

We need the size of values, otherwise we'll get different binary sequence. Without getting data aligned, library will get wrong data and thus lead the caller application crash.

For example, in 32-bit platform, pointer has 4 bytes; while in 64-bit platform, pointer has 8 bytes. Below comparison shows same pointer value has different result generated when passing to dynamic library.

```
# in 32-bit
0x00000000111111110000000011111111

# in 64-bit
0x0000000011111111000000001111111100000000111111110000000011111111
```

It's also essential to align some insufficient values to minimum size. For example, if a value has 6 bytes size in 64-bit platform, we need to add zero padding so that it has minimum 8 bytes.

!!! Long Long

Not every platform support types like `long long`.  FFI libraries might need to implement that internally. When using FFI library, watch out if you can use this feature.

!!! Callback

In C code, we often write Function Pointers. For example, in libuv, we have below definitions:

```
void (*uv_walk_cb)(uv_handle_t* handle, void* arg);

void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);
```

It's essential to have a way to map VM functions into FFI functions. Luckily, we have [[ffi_closure|http://www.chiark.greenend.org.uk/doc/libffi-dev/html/The-Closure-API.html#The-Closure-API]] to achieve that. It enables arbitrary functions to be passed into an FFI call.

What you needs are:

* allocate memory for ffi_closure
* write ffi_closure pointer to exchange.
* free memory for ffi_closure

!!! Garbage Collect

You don't need to care memory management due to GC is usually builtin in VM language. However, when writing FFI calls, you need to worry about low-level memory management problem. 

There is no C stack in FFI. Every data live either in native heap or VM-managed heap. Free those useless when becomes useless.

!!! Thread-safe v/s Thread-unsafe

Some C operations are not thread-safe. Be careful when calling them when you're writing concurrency.

!!! Advantage and Disadvantage

* Advantage
** Very good performance, as long as your C code not sucks.
** Reuse whatsoever in-place in system.
** Easily port C library to another VM language. For example, [[ImageMagick|https://www.imagemagick.org/script/api.php]] can be integrated into almost every VM language via FFI without changing C code.
* Disadvantage
** Introduce system dependency.
** Portability. Some interfaces might not work in another platform or architect. For example, you can't use Windows `MessageBoxA` in Linux.

!! Conclusions

!! References

* [[Flexible runtime interface to shared libraries with libffi|https://eli.thegreenplace.net/2013/03/04/flexible-runtime-interface-to-shared-libraries-with-libffi]]
* [[Why use FFI|https://github.com/ffi/ffi/wiki/Why-use-FFI]]
* [[LuaJit - FFI|http://luajit.org/ext_ffi.html]]
* [[Python - CFFI|https://cffi.readthedocs.io/en/latest/overview.html]]
* [[Using LibFFI|http://www.chiark.greenend.org.uk/doc/libffi-dev/html/Using-libffi.html#Using-libffi]]
* [[Java JNI example|https://stackoverflow.com/questions/5963266/call-c-function-from-java]]
* [[Pony - FFI|https://tutorial.ponylang.org/c-ffi/]]
* [[Rust - FFI|https://doc.rust-lang.org/book/first-edition/ffi.html]]
* [[CommonLisp - FFI|https://common-lisp.net/project/cffi/manual/cffi-manual.html]]
* [[Example of source code in this post|https://gist.github.com/soasme/1ddbf4de79e341cbf2e0cf7357a166f7]]
* [[How libffi actually works?|http://techbrahmana.blogspot.com/2008/08/how-libffi-actually-works.html]]