created: 20180815104239224
modified: 20180815112007438
tags: 
title: Raft - Exploiting the Stream Paradigm
type: text/vnd.tiddlywiki

Stream is a data structure that calculate data when we need them. Below is a typical stream implementation in Python.

```
from functools import lru_cache

class Stream:

    def __init__(self, head, restfn=None):
        self.head = head
        self.restfn = restfn

    @property
    def stopped(self):
        return self.restfn is None

    @property
    @lru_cache()
    def rest(self):
        assert not self.stopped, 'No rest for stopped stream.'
        return self.restfn()
```

Considering the usage, it often ends to a recursive definition. For example, a stream that always generate number `1` has below form:

```
def one_stream():
    return Stream(1, one_stream)
```

We can get `head` for the evaluated value, and `rest` for the rest of the stream.

```
>>> one_s = one_stream()
>>> print(one_s.head)
1
>> print(one_s.rest.head)
1
>>> print(one_s.rest.rest.head)
1
```

You might notice that `one_stream` creates an infinite stream, meaning the stream never stop generating `1`. We can indicate a stopped stream by setting `restfn` to None 

```
def countdown_stream(n):
    return Stream(n, (lambda: countdown_stream(n-1)) if n > 0 else None)

>>> countdown_s = countdown_stream(3)
>>> countdown_s.head
3
>>> countdown_s.rest.head
2
>>> countdown_s.rest.rest.head
1
>>> countdown_s.rest.rest.rest.head
0
>>> countdown_s.rest.rest.rest.stopped
True
```

The stream approach takes a different way of combining modules from Object-Oriented programming. We need to think of the history of time series for a module, rather than the states at any specific moment. Although we still handle states one by one, we don't care when it happens.

For example, given a raft follower stream, it only cares the datagram stream and either turns it into a new follower stream if received any datagram or converts to a new candidate stream.

```
def follower_stream(state):
    datagrams = datagram_stream(timeout=state.election_interval)
    timeout = datagrams.stopped
    state = reduce_stream(handle_datagram, datagrams, init=state)
    rest = lambda: candidate_stream(state) if timeout else follower_stream(state)
    return Stream(state, rest)
```

The `reduce_stream` can be very similar to the `reduce` function in functional programming. The `handle_datagram` transform an old `state` to a new `state` based on received datagram. The `candidate_stream` creates a new stream that perform candidate behaviors.
