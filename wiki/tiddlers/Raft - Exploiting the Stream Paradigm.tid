created: 20180815104239224
modified: 20180815112007438
tags: 
title: Raft - Exploiting the Stream Paradigm
type: text/vnd.tiddlywiki

Stream implementation.

```
from dataclasses import dataclass
from typing import Any
from functools import lru_cache

class Stream:

    def __init__(self, head, restfn=None):
        self.head = head
        self.restfn = restfn

    @property
    def stopped(self):
        return self.restfn is None

    @property
    @lru_cache()
    def rest(self):
        assert not self.stopped, 'No rest for stopped stream.'
        return self.restfn()
```

One stream

```
def one_stream():
    return Stream(1, one_stream)

one_s = one_stream()
print(one_s.head)
print(one_s.rest.head)
print(one_s.rest.rest.head)
```

Rand stream

```
from random import uniform

def random_stream(minimum, maximum):
    random = uniform(minimum, maximum)
    rest = lambda: random_stream(minimum, maximum)
    return Stream(random, rest)

rstream = random_stream(0.0, 1.0)
print(rstream.head)
print(rstream.rest.head)
print(rstream.rest.rest.head)
```

Iterate through stream

```
def iter_stream(stream):
    while not stream.stopped:
        state = stream.head
        stream = stream.rest

iter_stream(stream)
```

> The stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables. For example, we can think of an entire time series (or signal) as a focus of interest, rather than the values of the state variables at individual moments. This makes it convenient to combine and compare components of state from different moments.