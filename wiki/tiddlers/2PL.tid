created: 20180826110144223
modified: 20180826111336598
tags: 
title: 2PL
type: text/vnd.tiddlywiki

!! Context

The serializability is a concurrency control property that a transaction system guarantees each transaction is getting executed one by one.

The 2PL or Two-Phase Locking is such method to reach serializability.

!! Overview

The 2PL is straightforward like its name - it has two phases.

* Phase 1, growing phase.
** New locks may be acquired.
** None of them can be released.
* Phase 2, shrinking phase.
** Existing locks may be released.
** No new locks can be acquired.

Notably, a LOCK POINT is at which phase 1 ends, that is, when the transaction acquires the last lock it needs.

!! Patterns

!!! Shared Lock v/s Exclusive Lock

2PL handles below two locks.

* Shared Lock: nobody can write anything if one or more shared locks already exist.
* Exclusive Lock: nobody can read or write anything if an exclusive lock exists.

!!! Cascading Rollback

The cascading rollback is at when handling multiple transactions a failed transaction leads to all other transaction rollbacked in some cases.

For example, say we have below 3 transactions on 2 resources `x` and `y`.

* Transaction 1: read(x), write(x), read(y), rollback()
* Transaction 2: read(x), write(x), commit()
* Transaction 3: read(x), commit()

The scheduler proceeds the operations in below sequence: T1 read(x), T1 write(x), T1 read(y), T2 read(x), T2 write(x), T3 read(x), T1 rollback(), T2 rollback(), T3 rollback(). The dirty read in T2 and T3 causes the rollbacks.

Note: T1=Transaction 1, T2=Transaction 2, T3=Transaction 3. And so as below example.

The 2PL cannot avoid the cascading failure. 

!!! Deadlocks and Starvation

A deadlock is a state when each operation is waiting for some other operations to take action. However, no operation can proceed at all. When the deadlock happens, the system enters a state called starvation.

For example, say we have below two transactions on two resources `x` and `y`.

* Transaction 1: write(x), write(y)
* Transaction 2: write(y), write(x)

The scheduler proceeds the operations in below sequence: T1 write(x), T2 write(y), T1 write(y), T2 write(x). You might notice that none of T1 write(y) and T2 write(x) can proceed as for T1 resource y has been locked by T2, and T2 resource x has been locked by T1. 

The 2PL cannot avoid the deadlock.

!! Learn 2PL the hard way

I would recommend read the source code of [[strict-2pl|https://github.com/mauriciogardini/strict-2pl/blob/master/strict_2pl.py]]. This demo shows the sequence of 2PL in below cases:

* No conflicts.
* Some operations need to be delayed.
* Deadlock.

Below is the output of the application. Note that the application is written in Python 2. The notations has such format: `l` means lock, `u` means unlock, `r` means read, `w` means write, `[x]` and `[y]` are two resources, `c` means commit, `s` means shared lock, `x` means exclusive lock, `1` and `2` means the two transactions.

```
History with no conflicts
Original history: r1[x] r2[y] r1[y] c1 w2[x] c2
Final history: ls1[x], r1[x], ls2[y], r2[y], ls1[y], r1[y], c1, us1[x], us1[y], lx2[x], w2[x], c2, us2[y], ux2[x]
--------------------
History with an operation that needs to be delayed
Original history: r1[x] w1[x] w2[x] c1 c2
The operation w2[x] was delayed.
Final history: ls1[x], r1[x], lx1[x], w1[x], c1, us1[x], ux1[x], lx2[x], w2[x], c2, ux2[x]
--------------------
History with a deadlock
Original history: r1[x] w2[y] r1[y] w2[x] c1 c2
The operation r1[y] was delayed.
The operation w2[x] was delayed.
A deadlock was found. The transaction 2 was aborted.
Final history: ls1[x], r1[x], ls1[y], r1[y], c1, us1[y], us1[x], lx2[y], w2[y], lx2[x], w2[x], c2, ux2[x], ux2[y]
--------------------
History with an operation that can't be executed
Original history: r1[x] r2[y] r1[y] c1 r1[x] w2[x] c2
The operation r1[x] will be ignored because its transaction is in the shrinking phase.
Final history: ls1[x], r1[x], ls2[y], r2[y], ls1[y], r1[y], c1, us1[x], us1[y], lx2[x], w2[x], c2, ux2[x], us2[y]
--------------------
History with more than one operation that has to be delayed
Original history: r1[x] w1[x] w2[x] r2[y] w2[y] c1 c2
The operation w2[x] was delayed.
The operation r2[y] was delayed.
The operation w2[y] was delayed.
Final history: ls1[x], r1[x], lx1[x], w1[x], c1, us1[x], ux1[x], lx2[x], w2[x], ls2[y], r2[y], lx2[y], w2[y], c2, ux2[y], ux2[x], us2[y]
--------------------
```

!! References

* [[Wikipedia - Two-phase locking|https://en.wikipedia.org/wiki/Two-phase_locking]]
* [[Two Phase Locking (2-PL)-I|https://www.geeksforgeeks.org/dbms-concurrency-control-protocols-two-phase-locking-2-pl/]]