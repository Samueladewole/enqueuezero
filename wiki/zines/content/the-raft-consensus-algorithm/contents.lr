_model: topic
---
title: The Raft Consensus Algorithm
---
body:

#### raw-block ####
contents:

<header style="padding: 20px 0 50px;border-bottom: 1px solid rgba(34,34,34,0.2);background:url(cell.png) 0 50%;background-color: #73bfff; box-shadow: inset 0 10px 10px #73cfff">
  <div style="text-align: center; color: #fff; text-shadow: 1px 1px 2px rgba(34,34,34,0.5);padding: 5% 0 0 10%;">
    <h1 style="color:#fff;">The Raft Consensus Algorithm</h1>
    <h2 style=>He was elected democratically but rules as a tyrant.<br>His people obey his order faithfully.</h2>
  </div>
</header>
</div>
#### text-block ####
text:

### What is the background of Raft?

Let's talk about the consensus problem here.

### What is the Raft consensus algorithm?

* Elect a leader among all nodes.
* Only the leader can serve to write commands.
* The leader sync commands to the other nodes.

### How is the Raft leader elected?

* Every node either follows a leader or elects self if no leader sensed.
* After elected, this node gathers votes. If a majority of nodes votes him, he becomes a leader. Otherwise, he steps back to a follower.

### How does Raft reach consensus?

* The leader send heartbeats to other nodes to maintain authority, which includes all commands not synced to the follower nodes.
----
background: 
----
class: default
#### raw-block ####
contents:

<div class="raw-header" style="color: #ffffff; padding: 5% 0 0 10%; height: 200px;background-color:#00a3aa;">
<h3>Unhappy Path</h3>
<p class="hvr-icon-pulse">Want to see more posts? Follow
<i class="fa fa-twitter hvr-icon"></i>
<a href="https://twitter.com/enqueuezero" style="color: #ffffff;border-bottom:solid 2px #ffffff;">@enqueuezero</a> in Twitter.
</p>
</div>
#### qa-block ####
id: follower-crash
----
q: What if a follower node crash?
----
a: * It doesn't matter if we lose nodes less than (totalNumberOfNodes / 2).
----
arrow_color: #00a3aa
#### qa-block ####
id: leader-crash
----
q: What if a leader node crash?
----
a:

* We might see a few seconds downtime.
* Followers would elect a new leader to replace old one.
----
arrow_color: #00a3aa
#### qa-block ####
id: candidate-crash
----
q: What if a candidate node crash?
----
a: * It doesn't matter. Other followers would always elect themselves if no candidate wins the election in a term.
----
arrow_color: #00a3aa
#### qa-block ####
id: network-partitioned
----
q: What if the network is partitioned?
----
a: TODO
----
arrow_color: #00a3aa
#### qa-block ####
id: network-recovered
----
q: What if the network is recovered?
----
a: TODO
----
arrow_color: #00a3aa
#### raw-block ####
contents:

<div class="raw-header" style="color: #ffffff; padding: 5% 0 0 10%; height: 200px;background-color:#3381CD;">
<h3>Time & Communication</h3>
<p class="hvr-icon-pulse">More questions? Ask me by
<i class="fa fa-github hvr-icon"></i>
<a href="https://github.com/soasme/enqueuezero" style="color: #ffffff;border-bottom:solid 2px #ffffff;">opening an issue</a>.
</p>
</div>
#### text-block ####
text:

### The nature of time

The Raft consensus algorithm assumes nodes are in the vicinity, meaning they should be able to communicate very fast. Let's imagine the case of one node on Earth, one node on Mars, and one node on the Moon. It would take minutes for messages communicating between nodes and hence minutes to reach consensus with the best of luck. Most people would rather deploy Raft nodes in one Data Center for the best performance. Also, the defaults heartbeat and election timeout are set to a hundred milliseconds to a few seconds.

[Animation here]

At a given moment, the states of different nodes in the Raft cluster are very likely different, meaning they might return different values for a `GET` command for the same key. The reason is that the Raft consensus algorithm only ensures EVENTUAL CONSENSUS, though we don't know the exact time of reaching consensus. It could be a hundred milliseconds after a heartbeat or a few hours for a crashed node to catch up with the latest leader's state. In essence, it needs time to reach consensus.

[Animation here]

In fact, any notion of time in the distributed system control must be tightly tied to the communication. The network latency adds the time the most. Interestingly, the relation of time and communication also appears in Albert Einstein's Theory of Relativity. It seems that it's one the tough problems we need to solve in the physical universe, not necessarily in the Computer Science.

### The network is unreliable

The synchronization of the Raft states among nodes in the cluster imposes an order on messages.  However, the network is always unreliable.

Sometimes, it plays likes a thief stealing your data packets.

[Animation Here]

Sometimes, it plays like a jerk swapping the order of data packets sending to a node. 

[Animation Here]

One of the major problems Raft solves is to keep the order of messages correctly. It applies an algorithm on the data in the packets, to commit those valid, and to reject those invalid. The timeout can still cause problems, but Raft leader resends the information.
----
background: 
----
class: default
#### raw-block ####
contents:

<div class="raw-header" style="color: #ffffff; padding: 5% 0 0 10%; height: 200px;background-color:#00ab84;">
<h3>Streams</h3>
<p class="hvr-icon-pulse">Want to see more similar crafts? Consider <i class="fa fa-credit-card hvr-icon"></i>
<a href="https://www.patreon.com/bePatron?c=1762267" style="color:#e5f3f6;border-bottom:solid 2px #ffffff;">donating via Patreon</a>.
</p>
</div>
#### text-block ####
text:

### Streams Are Delayed Lists

In this section, we explore a minority approach to modeling the Raft state, based on data structures called `streams`. We can certainly use a more Object-Oriented way to implement it, however, if we concentrate on the entire time history of data packets, our functions only need to handle a state and generate a new state. This would simplify our implementation.

From an abstract point of view, a stream is simply a sequence.

```python
class Stream(object):
    def __init__(self, head, rest_fn, exit=None):
        self.head = head
        self.exit = exit
        self._rest = None
        self._rest_fn = rest_fn
        self._evaluated = False

    @property
    def stopped(self):
        return bool(self.exit)

    @property
    def rest(self):
        assert not self.stopped, 'Stopped stream has no rest.'
        if not self._evaluated:
            self._rest = self._rest_fn()
            self._evaluated = True
        return self._rest
```

### Stopwatch & Infinite Stream

```python
def stopwatch(period, start=None):
    start = start or time()
    head = max(0, period - (time() - start))
    rest = lambda: stopwatch(period, start)
    return Stream(head, rest, exit=not head)
```

```
>>> stream = stopwatch(10)
>>> print(stream.head)
9.999999046325684
>>> print(stream.rest.head)
2.888666868209839
>>> print(stream.rest.rest.head)
0.5928409099578857
>>> print(stream.rest.rest.rest.head)
0
>>> print(stream.rest.rest.rest.rest.head)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/private/tmp/raft-101/raft.py", line 26, in rest
    assert not self.stopped, 'Stopped stream has no rest.'
AssertionError: Stopped stream has no rest.
```

### Data Stream & Finite stream

```python
def receive(udp_server, timeout):
    udp_server.settimeout(timeout)
    try:
        datagram, address = udp_server.recvfrom(8192)
        return Datagram(address, json.loads(datagram.decode()))
    except socket.timeout:
        return

def keep_receiving(udp_server, second, left=None):
    left = left or stopwatch(second)
    data = receive(udp_server, left.head) if not left.stopped else None
    rest = lambda: keep_receiving(udp_server, second, left.rest)
    return Stream(data, rest, exit=data is None)
```

### Finite State Machine as a Stream

```python
def reduce_stream(fn, s, init):
    elem = init
    while not s.stopped:
        elem = fn(elem, s.head)
        s = s.rest
    return elem
```

```python
def make_follower_stream(state):
    datagram_stream = keep_receiving(udp_server, uniform(1.5, 4.5))
    election_timeout = datagram_stream.stopped
    state = reduce_stream(follower_handle_datagram, datagram_stream, state)
    def rest():
        if election_timeout:
            return make_candidate_stream(state)
        else:
            return make_follower_stream(state)
    return Stream(state, rest)
```

```python
def make_candidate_stream(state):
    state = elect_self(state)
    datagram_stream = keep_receiving(udp_server, uniform(1.5, 4.5))
    election_timeout = datagram_stream.stopped
    state = reduce_stream(candidate_handle_datagram, datagram_stream, state)
    def rest():
        if election_timeout:
            return make_candidate_stream(state)
        elif state.server_state == 'follower':
            return make_follower_stream(initialize_follower(state))
        elif state.server_state == 'leader':
            return make_leader_stream(initialize_leader(state))
    return Stream(state, rest)
```

```python
def make_leader_stream(state):
    state = send_heartbeat(state)
    datagram_stream = keep_receiving(udp_server, 0.3)
    state = reduce_stream(leader_handle_datagram, datagram_stream, state)
    def rest():
        if state.server_state == 'follower':
            return make_follower_stream(initialize_follower(state))
        else:
            return make_leader_stream(state)
    return Stream(state, rest)
```
----
background: 
----
class: default
