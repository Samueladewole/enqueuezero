---
title: EnqueueZero Techshack 2019-05
sidebar: auto
published: true
description:
tags: enqueuezero,
---

# EnqueueZero Techshack 2019-05

<TechshackHeader />

## Our Software Dependency Problem

[swtch.com](https://research.swtch.com/deps)

* A dependency is additional code that you want to call from your program. Adding a dependency avoids repeating work already done: designing, writing, testing, debugging, and maintaining a specific unit of code.
* A dependency manager (sometimes called a package manager) automates the downloading and installation of dependency packages.
* When consuming software dependencies,
  * Recognize the problem.
  * Establish best practices for today.
  * Develop better dependency technology for tomorrow.

## Systemd as tragedy

[lwn.net](https://lwn.net/SubscriberLink/777595/a71362cc65b1c271/)

## Finding Kafka’s throughput limit in Dropbox infrastructure

[blogs.dropbox.com](https://blogs.dropbox.com/tech/2019/01/finding-kafkas-throughput-limit-in-dropbox-infrastructure/)

## Highly Available MySQL Clusters at WePay

[wecode.wepay.com](https://wecode.wepay.com/posts/highly-available-mysql-clusters-at-wepay)

Core components are Orchestrator, Consul, HAProxy, and pt-heartbeat.

* Orchestrator is for detecting failures and role transition.
* There are two layers of HAProxy.
  * The first layer of HAProxy sits on the client machines and connects to the remote (second layer) of HAProxy.
  * The second layer of HAProxy is distributed across multiple Google zones that connect to the same set of MySQL servers
* Consul is the KV store.
* Heartbeat runs on every host.

## CockroachDB's Consistency Model

[cockroachlabs.com](https://www.cockroachlabs.com/blog/consistency-model/)

## CockroachDB on RocksDB

[cockroachlabs.com](https://www.cockroachlabs.com/blog/cockroachdb-on-rocksd/)

## It’s Time to Move on from Two Phase Commit

[dbmsmusings.blogspot.com](http://dbmsmusings.blogspot.com/2019/01/its-time-to-move-on-from-two-phase.html)

## Selecting a Software Architecture

[www.javacodegeeks.com](https://www.javacodegeeks.com/2019/01/selecting-software-architecture.html)

## A Lifetime of Systems Thinking

[thesystemsthinker.com](https://thesystemsthinker.com/a-lifetime-of-systems-thinking/)

## Lessons learned scaling PostgreSQL database to 1.2bn records/month

[medium.com](https://medium.com/@gajus/lessons-learned-scaling-postgresql-database-to-1-2bn-records-month-edc5449b3067)

## Programming paradigms for dummies: what every programmer should know

[blog.acolyer.org](https://blog.acolyer.org/2019/01/25/programming-paradigms-for-dummies-what-every-programmer-should-know/)


## High-Performance in Python with Zero-Copy and the Buffer Protocol

[julien.danjou.info](https://julien.danjou.info/high-performance-in-python-with-zero-copy-and-the-buffer-protocol/)

## PostgreSQL on Kubernetes the Right Way

Part I: [medium.com](https://medium.com/kokster/postgresql-on-kubernetes-the-right-way-part-one-d174ee8a56e3) | Part II: [medium.com](https://medium.com/kokster/postgresql-on-kubernetes-the-right-way-part-two-1a981d5fb747)

Challenges:
* High Availability
* Load Balancing
* Synchronization Between Instances
* Scaling Up and Down
* Automated Backup, Recovery from Backup
* Rolling Upgrades/Downgrades
* Health Monitoring, Debugging

PostgreSQL follows the master-slave pattern. There’s a single authoritative primary server (master) and some number of standby servers (slaves) that mirror the primary. This distributed architecture serves two purposes:

* Failover — If the primary fails, a standby can take its place. 
* Load Balancing — Standbys can handle read-only requests, reducing load on the primary.

Additionally, the primary continuously archives its write-ahead log (WAL) and periodically creates backups of its entire state (called base backups).

In Kubernetes, there are Primary and Standby Pods

* Primary — Typically only one instance, used for reads and writes.
* Standby — Many of these, used for reads, can be promoted to primary


## Scaling Azure Functions to Make 500,000 Requests to Weather.com in Under 3 Minutes

[madeofstrings.com](https://madeofstrings.com/2019/01/09/scaling-azure-functions-to-make-500000-requests-to-weather-com-in-under-3-minutes/)

* The challenges: pull 50k data and complete the process in 5 min; repeat every 15 min.
* Overall Design:
  ![overall design](https://madeofstrings.files.wordpress.com/2019/01/weather-highlevel-steps.png)
  * Coordinates are stored in Azure Table Storage. Records are immutable.
  * Durable Functions are used to populate a group of Storage Queues with the coordinates from the table. Each message represents a pending request to the weather service.
  * An Azure Function is invoked for each message in the queue.
  * Requests are made to the 3rd party service to get the forecast details.
  * The results of the forecast requests are published to Event Hubs for further processing.
* To make queue-triggered function run faster,  the loads (data fetching requests) are distributed to multiple queues.
  ![load balancing](https://madeofstrings.files.wordpress.com/2019/01/weather-load-balance.png)
* Data partitioning: In short, every set of 1,000 records was given a unique partition key that had the following naming convention: {queue-number}-{partition-count}. So the first 1,000 records for queue #1 would have the partition key 1-0. The next 1,000 records would be assigned the key 1-1.

## Serverless at Scale: Serving StackOverflow-like Traffic

[blog.binaris.com](https://blog.binaris.com/serverless-at-scale/)

* Function-as-a-Service is a great model to build applications that can work for low-usage scenarios, high-load applications, and even spiky workloads.
* Scalability limits do exist, so if you anticipate high growth in the application’s usage, run a simple load test to see how it behaves.
* Always test in combination with your non-serverless dependencies. If you use a database or a third-party service, it’s quite likely they will hit the scalability limit much earlier than the serverless compute.

## Why we use Ruby on Rails to build GitLab

[about.gitlab.com](https://about.gitlab.com/2018/10/29/why-we-use-rails-to-build-gitlab/)

* The Ruby on Rails ecosystem allows you to shape a lot of functionality at a high quality.
* There's a great ecosystem around it with gems that can make assumptions about how you're doing things.
* Some critical backend components are written in Go, and some frontend components are written in Vue.
* In every kitchen you enter, you never know where the knives and plates are located. But with Ruby on Rails, you enter the kitchen and it's always in the same place, and we want to stick to that. (My thought, same rule applies to Django, React, ...)

## websocketd - Turn any program that uses STDIN/STDOUT into a WebSocket server. Like inetd, but for WebSockets.

[github.com](https://github.com/joewalnes/websocketd)

Example script `count.sh`:

```bash
#!/bin/bash
for ((COUNT = 1; COUNT <= 10; COUNT++)); do
  echo $COUNT
  sleep 1
done
```

```bash
$ websocketd --port=8080 ./count.sh
```

##

[twitter.com](https://twitter.com/antirez/status/1088459749287493632)

> It's a few weeks that I just code RESP3 and ACLs without caring much about the issues in the Redis repository. I'm doing my best with ACLs, I like the code and how the feature is exposed from an UX perspective. It's a joy to code, while dealing with issues / PRs is stressful. However there is no way out, from time to time one need to focus on the issues / PRs. I guess that I'm just a better coder than a better maintainer. I'll continue my context switch like in the past years, but for me to don't care about issues from time to time is *a key thing*. The odd thing is that a project becomes popular because apparently you can write some code and design some things. And suddenly your job becomes checking other people's code and designs: the project ends being less and less about your work quality, unless you say no 99% of times
